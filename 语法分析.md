## 语法分析

在语法分析阶段根据词法阶段分析出的源文件token数据流构建出语法树。

由parse.py的Parse类完成此工作。

在 Parse.main() 函数中对token数据流进行迭代分析：

```python
def main(self):
    index = 0
    while index < len(self.tokens):
        index = self.parse(index,self.grammar_tree)
```

在Parse.pars()函数中根据token的类型或者token的上下文类型，生成不同的语法树节点:

```python
def parse(self,index_init,gram_root):
	index = index_init
	# print(self.tokens[index].type,self.tokens[index].value)
	if self.tokens[index].type == 'T_r3_braket':
		return index+1
	# 遇到了类型token，很可能是一个变量声明
	elif self.retTokenType(index) == 'VarDeclaration':
		# print("debug line 381",gram_root.key)
		index = self.VarDeclaration(index,gram_root)
	# 也有可能是函数定义捏
	elif self.retTokenType(index) == 'FuncDeclaration':
		index = self.FuncDeclaration(index,gram_root)
		# print(index,len(self.tokens))
		# print(index,self.tokens[index].value)
	# 修饰符开头？首先考虑是一条语句
	elif self.retTokenType(index) == 'Stmt':
		ret_node,index = self.Statemet(index,gram_root)
		gram_root.add_child(ret_node)
		# print('debug line 405',ret_node.key,gram_root.key)
	# 也有可能是函数调用捏
	elif self.retTokenType(index) == 'FunctionCall':
		funcall_tree, index = self.FunctionCall(index)
		gram_root.add_child(funcall_tree)
		# break
	# 一个简单的修饰符罢了
	elif self.retTokenType(index) == 'Identifier':
		index = self.Identifier(index,gram_root)
	# 常数
	elif self.retTokenType(index) == 'Constant':
		index = self.Constant(index,gram_root)
	# 赋值语句
	elif self.retTokenType(index) == 'Assign':
		index = self.Assign(index,gram_root)
	elif self.retTokenType(index) == 'If':
		index = self.If(index,gram_root)
	elif self.retTokenType(index) == 'While':
		index = self.While(index,gram_root)
	elif self.retTokenType(index) == 'Break':
		index = self.Break(index,gram_root)
	elif self.retTokenType(index) == 'For':
		index = self.For(index,gram_root)
	else:
		index += 1
	return index
```

节点类型主要由Parse.retTokenType()函数进行判断：

```python
def retTokenType(self,index):
	# type 为类型关键字？很可能是变量声明或者函数声明
	if self.tokens[index].type == 'T_int' or self.tokens[index].type == 'T_char' or self.tokens[index].type == 'T_void':
		retType = 'VarDeclaration'
		index_tmp = index
		index_tmp += 1
		# 'Type inden'
		if self.tokens[index_tmp].type == 'T_identifier':
			# 'Type inden(' 大概率是函数
			if self.tokens[index_tmp+1].type == 'T_l1_bracket':
				retType = 'FuncDeclaration'
		return retType
	# type 为标识符,分为多种情况
	elif self.tokens[index].type == 'T_identifier':
		retType =  'Stmt'
		# 'iden(*' ,归为函数调用
		if self.tokens[index+1].type == 'T_l1_bracket':
			retType = 'FunctionCall'
		# 'iden,*' 归为普通的语句
		elif self.tokens[index+1].type == 'T_comma' or self.tokens[index+1].type == 'T_r1_bracket':
			# print('line 288',self.tokens[index+1].value)
			retType = 'Identifier'
		# 'iden = *',赋值语句
		elif self.tokens[index+1].type in ['T_assign','T_add_assign','T_sub_assign','T_mul_assign','T_div_assign','T_notequal','T_equal']:
			retType = 'Assign'
		# print("debug line 383 ",self.tokens[index+1].value,retType)
		return retType
	# 常数
	elif self.tokens[index].type == 'T_constant':
		return 'Constant'
	# if
	elif self.tokens[index].type == 'T_if':
		return 'If'
	# while
	elif self.tokens[index].type == 'T_while':
		return 'While'
	# break
	elif self.tokens[index].type == 'T_break':
		return 'Break'
	# for
	elif self.tokens[index].type == 'T_for':
		return 'For'
```

